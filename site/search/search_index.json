{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"fundamentos/","title":"M\u00f3dulo 1: Fundamentos de Git y GitHub","text":"\ud83c\udfaf Objetivo del M\u00f3dulo <p>Entender qu\u00e9 es Git, qu\u00e9 es GitHub y c\u00f3mo se relacionan. Configurar el entorno local y remoto para empezar a trabajar en el proyecto \"CollabApp\".</p>"},{"location":"fundamentos/#1-que-es-el-control-de-versiones","title":"\ud83d\udcdc 1. \u00bfQu\u00e9 es el Control de Versiones?","text":"<p>El Control de Versiones (VCS) es un sistema que registra los cambios realizados en un archivo o conjunto de archivos a lo largo del tiempo. Esto permite recuperar versiones espec\u00edficas m\u00e1s adelante, comparar cambios, y colaborar de manera m\u00e1s eficiente.</p> <p>Pi\u00e9nsalo como: Un historial detallado de \"guardados\" de tu proyecto, permiti\u00e9ndote volver atr\u00e1s o entender la evoluci\u00f3n del mismo.</p>"},{"location":"fundamentos/#2-git-vs-github-entendiendo-la-diferencia","title":"\ud83c\udd9a 2. Git vs. GitHub: Entendiendo la Diferencia","text":"<p>Es crucial distinguir entre estas dos herramientas que, aunque relacionadas, cumplen funciones diferentes:</p> <ul> <li> <p>Git:</p> <ul> <li>Es el software de control de versiones distribuido que se ejecuta en tu computadora.</li> <li>Permite rastrear cambios, crear ramas, fusionar trabajo, etc., de forma local.</li> <li>Es la herramienta fundamental para la gesti\u00f3n de versiones.</li> </ul> </li> <li> <p>GitHub:</p> <ul> <li>Es una plataforma web que aloja repositorios Git en la nube.</li> <li>Facilita la colaboraci\u00f3n en equipo, la revisi\u00f3n de c\u00f3digo (Pull Requests), la gesti\u00f3n de proyectos (Issues), y sirve como un \"backup\" centralizado y accesible de tu c\u00f3digo.</li> <li>Act\u00faa como un hub central para los repositorios Git.</li> </ul> </li> </ul> <p>En resumen: <code>Git</code> es el motor, <code>GitHub</code> es la plataforma que potencia su uso colaborativo en la web.</p>"},{"location":"fundamentos/#3-instalacion-y-configuracion-de-git","title":"\u2699\ufe0f 3. Instalaci\u00f3n y Configuraci\u00f3n de Git","text":"<p>Para empezar a usar Git, primero necesitas instalarlo y configurarlo.</p> Paso 1: Instalaci\u00f3n de Git <p>Visita https://git-scm.com/downloads y descarga el instalador adecuado para tu sistema operativo (Windows, macOS, Linux). Sigue las instrucciones del instalador.</p> Paso 2: Configuraci\u00f3n Inicial de Identidad <p>Una vez instalado, abre una terminal (Git Bash en Windows, Terminal en macOS/Linux) y configura tu nombre de usuario y correo electr\u00f3nico. Estos datos se asociar\u00e1n a tus commits. <pre><code>git config --global user.name \"Tu Nombre Completo\"\ngit config --global user.email \"tu.email@ejemplo.com\"\n</code></pre> *   La opci\u00f3n <code>--global</code> aplica esta configuraci\u00f3n a todos tus proyectos Git.</p>"},{"location":"fundamentos/#4-conceptos-clave-de-git-trabajo-local","title":"\ud83d\udd11 4. Conceptos Clave de Git (Trabajo Local)","text":"<p>Estos son los pilares del trabajo con Git en tu m\u00e1quina:</p> <ul> <li> <p>Repositorio (<code>git init</code>):</p> <ul> <li>Es la carpeta de tu proyecto que Git va a rastrear. Se crea ejecutando <code>git init</code> dentro de la carpeta del proyecto.</li> <li>Caso CollabApp: Ana crea una carpeta <code>CollabApp</code> y la inicializa:     <pre><code>mkdir CollabApp\ncd CollabApp\ngit init\n</code></pre></li> </ul> </li> <li> <p>\u00c1rea de Staging (<code>git add</code>):</p> <ul> <li>Antes de confirmar (hacer commit) los cambios, debes seleccionar expl\u00edcitamente qu\u00e9 modificaciones quieres incluir en la pr\u00f3xima \"foto\" del proyecto.</li> <li><code>git add &lt;nombre_archivo&gt;</code>: A\u00f1ade un archivo espec\u00edfico al staging area.</li> <li><code>git add .</code>: A\u00f1ade todos los archivos modificados o nuevos en el directorio actual y subdirectorios.</li> <li>Caso CollabApp: Ana crea <code>README.md</code> y lo a\u00f1ade al staging:     <pre><code>echo \"# CollabApp - Herramienta de Gesti\u00f3n de Tareas\" &gt; README.md\ngit add README.md\n</code></pre></li> </ul> </li> <li> <p>Confirmaciones / Commits (<code>git commit</code>):</p> <ul> <li>Es el acto de guardar los cambios preparados (staged) en el historial del repositorio. Cada commit es una \"instant\u00e1nea\" del proyecto en un momento dado.</li> <li>Es crucial escribir un mensaje de commit claro y descriptivo.     <pre><code>git commit -m \"feat: Inicializar proyecto con README b\u00e1sico\"\n</code></pre></li> </ul> <p>Convenciones de Mensajes de Commit</p> <p>Es una buena pr\u00e1ctica usar prefijos para indicar el tipo de cambio (ej. <code>feat:</code> para nueva funcionalidad, <code>fix:</code> para correcci\u00f3n, <code>docs:</code> para documentaci\u00f3n, <code>style:</code>, <code>refactor:</code>, <code>test:</code>, <code>chore:</code> para mantenimiento).</p> </li> <li> <p>Historial (<code>git log</code>):</p> <ul> <li>Muestra la lista de commits realizados, qui\u00e9n los hizo, cu\u00e1ndo y con qu\u00e9 mensaje.     <pre><code>git log\n</code></pre></li> </ul> </li> <li> <p>Estado (<code>git status</code>):</p> <ul> <li>Muestra el estado actual de tus archivos: modificados pero no en staging, en staging, sin rastrear, o si la rama actual est\u00e1 al d\u00eda con la remota. Es un comando que usar\u00e1s constantemente.     <pre><code>git status\n</code></pre></li> </ul> </li> </ul>"},{"location":"fundamentos/#5-creacion-de-una-cuenta-en-github","title":"\ud83c\udf10 5. Creaci\u00f3n de una Cuenta en GitHub","text":"<p>Dir\u00edgete a https://github.com y sigue el proceso de registro (\"Sign up\") para crear tu cuenta personal.</p>"},{"location":"fundamentos/#6-creacion-de-un-repositorio-remoto-en-github","title":"\u2601\ufe0f 6. Creaci\u00f3n de un Repositorio Remoto en GitHub","text":"<p>Una vez con tu cuenta, puedes crear repositorios para alojar tus proyectos.</p> <ul> <li>Caso CollabApp: Ana, desde su cuenta de GitHub:<ol> <li>Clic en el icono \"+\" (esquina superior derecha) \u27a1\ufe0f \"New repository\".</li> <li>Repository name: <code>CollabApp</code></li> <li>Description: (Opcional) \"Proyecto de herramienta de gesti\u00f3n de tareas.\"</li> <li>Elige entre Public o Private. (Para CollabApp, eligen Privado).</li> <li>Importante: No selecciones \"Initialize this repository with a README\", \".gitignore\", o \"license\" si ya tienes un proyecto local existente que quieres subir.</li> <li>Clic en \"Create repository\".</li> </ol> </li> </ul>"},{"location":"fundamentos/#7-conectar-repositorio-local-con-remoto-y-subir-cambios","title":"\ud83d\udd17 7. Conectar Repositorio Local con Remoto y Subir Cambios","text":"<p>Ahora, vincularemos el repositorio local de Ana con el que acaba de crear en GitHub.</p> Pasos para Conectar y Subir <ol> <li> <p>A\u00f1adir el Remoto:     GitHub te proporcionar\u00e1 una URL para tu repositorio remoto (ej. <code>https://github.com/TuUsuario/CollabApp.git</code>). Usa esta URL para \"registrar\" el remoto en tu Git local:     <pre><code># (Dentro de la carpeta local CollabApp)\ngit remote add origin https://github.com/TuUsuario/CollabApp.git\n</code></pre></p> <ul> <li><code>origin</code> es el nombre por defecto y m\u00e1s com\u00fan para el repositorio remoto principal.</li> </ul> </li> <li> <p>Verificar Remotos Configurados: <pre><code>git remote -v\n</code></pre>     Esto mostrar\u00e1 las URLs para <code>fetch</code> (traer) y <code>push</code> (enviar) de <code>origin</code>.</p> </li> <li> <p>(Opcional pero Recomendado) Renombrar Rama Principal a <code>main</code>:     Si tu rama principal local se llama <code>master</code> (com\u00fan en versiones antiguas de Git), es buena pr\u00e1ctica renombrarla a <code>main</code>:     <pre><code>git branch -M main\n</code></pre></p> </li> <li> <p>Empujar (Push) los Commits Locales al Remoto:     La primera vez que empujas a un nuevo repositorio o una nueva rama, necesitas especificar a d\u00f3nde van los cambios y establecer un seguimiento (upstream):     <pre><code>git push -u origin main\n</code></pre></p> <ul> <li><code>-u</code> (o <code>--set-upstream</code>) vincula tu rama <code>main</code> local con la rama <code>main</code> en <code>origin</code>.</li> <li>En pushes subsecuentes desde esta rama, solo necesitar\u00e1s <code>git push</code>.</li> </ul> </li> </ol>"},{"location":"fundamentos/#8-clonar-un-repositorio-remoto-git-clone","title":"\ud83d\udce5 8. Clonar un Repositorio Remoto (<code>git clone</code>)","text":"<p>Para que otros miembros del equipo (Bruno y Carla) puedan trabajar en \"CollabApp\", necesitan obtener una copia del proyecto.</p> <ul> <li>Caso CollabApp: Bruno y Carla ejecutan en sus terminales:     <pre><code>git clone https://github.com/UsuarioDeAna/CollabApp.git\n</code></pre><ul> <li>Esto crea una carpeta <code>CollabApp</code> en sus m\u00e1quinas con todo el proyecto.</li> <li>Autom\u00e1ticamente configura el remoto <code>origin</code> para apuntar al repositorio de GitHub desde donde se clon\u00f3.</li> </ul> </li> </ul>"},{"location":"fundamentos/#9-sincronizar-cambios-push-y-pull","title":"\ud83d\udd04 9. Sincronizar Cambios: <code>push</code> y <code>pull</code>","text":"<p>La colaboraci\u00f3n implica enviar y recibir cambios:</p> <ul> <li> <p><code>git push</code>:</p> <ul> <li>Env\u00eda tus commits locales (que est\u00e1n en tu m\u00e1quina pero no en GitHub) al repositorio remoto.</li> <li>Ejemplo: Despu\u00e9s de hacer nuevos commits, Ana ejecuta <code>git push</code> para compartir su progreso.</li> </ul> </li> <li> <p><code>git pull</code>:</p> <ul> <li>Trae los cambios del repositorio remoto a tu copia local y trata de fusionarlos con tu trabajo actual.</li> <li>Es una combinaci\u00f3n de <code>git fetch</code> (que descarga los cambios remotos) y <code>git merge</code> (que los integra).</li> <li>Ejemplo: Antes de empezar a trabajar, o para obtener los cambios de Ana, Bruno ejecuta <code>git pull origin main</code>.</li> </ul> </li> </ul>"},{"location":"fundamentos/#10-archivos-esenciales-gitignore-y-readmemd","title":"\ud83d\udcc4 10. Archivos Esenciales: <code>.gitignore</code> y <code>README.md</code>","text":"<p>Dos archivos son cruciales para la buena gesti\u00f3n de un repositorio:</p> <ul> <li> <p><code>.gitignore</code>:</p> <ul> <li>Un archivo de texto plano llamado <code>.gitignore</code> (con el punto al inicio).</li> <li>Especifica archivos y carpetas que Git debe ignorar y no rastrear.</li> <li>Esencial para evitar subir archivos generados, dependencias (ej. <code>node_modules/</code>), archivos de configuraci\u00f3n del IDE, o datos sensibles.</li> <li>Ejemplo de contenido para <code>.gitignore</code> en CollabApp: <pre><code># Dependencias\nnode_modules/\nvendor/\n\n# Archivos de entorno (\u00a1Nunca subir secretos!)\n.env\n*.env.local\n\n# Logs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Archivos de build/distribuci\u00f3n\ndist/\nbuild/\n\n# Archivos de sistema operativo\n.DS_Store\nThumbs.db\n</code></pre></li> <li>Importante: Crea, a\u00f1ade y commitea tu <code>.gitignore</code> al repositorio.     <pre><code># Crear el archivo .gitignore con el contenido deseado\ngit add .gitignore\ngit commit -m \"chore: A\u00f1adir archivo .gitignore con patrones b\u00e1sicos\"\ngit push\n</code></pre></li> </ul> </li> <li> <p><code>README.md</code>:</p> <ul> <li>Es la \"portada\" de tu proyecto en GitHub. Escrito en formato Markdown.</li> <li>Debe proporcionar una descripci\u00f3n clara del proyecto: qu\u00e9 hace, c\u00f3mo instalarlo, c\u00f3mo usarlo, y (eventualmente) c\u00f3mo contribuir.</li> <li>Es lo primero que un visitante (o un nuevo miembro del equipo) ver\u00e1.</li> </ul> </li> </ul>"},{"location":"fundamentos/#practica-sugerida","title":"\ud83d\udee0\ufe0f Pr\u00e1ctica Sugerida","text":"Ejercicio 1: Configuraci\u00f3n y Primer Repositorio Individual <ol> <li>Aseg\u00farate de que Git est\u00e9 instalado y configurado con tu <code>user.name</code> y <code>user.email</code>.</li> <li>Crea una cuenta en GitHub si no la tienes.</li> <li>En GitHub, crea un nuevo repositorio privado llamado <code>mi-primer-proyecto-colaborativo</code> (sin inicializarlo con archivos).</li> <li>En tu m\u00e1quina local, crea una carpeta con el mismo nombre, entra en ella e inicializa un repositorio Git (<code>git init</code>).</li> <li>Crea un archivo <code>README.md</code> con una breve descripci\u00f3n de lo que har\u00edas en un proyecto colaborativo.</li> <li>Crea un archivo <code>.gitignore</code> e incluye al menos <code>*.log</code> y una carpeta como <code>temp/</code> o <code>cache/</code>.</li> <li>A\u00f1ade ambos archivos al staging area (<code>git add .</code>).</li> <li>Realiza un commit con un mensaje descriptivo (ej. <code>feat: Configuraci\u00f3n inicial del proyecto con README y gitignore</code>).</li> <li>Conecta tu repositorio local con el remoto de GitHub (<code>git remote add origin &lt;URL_DE_TU_REPO&gt;</code>).</li> <li>(Si es necesario) Renombra tu rama principal a <code>main</code> (<code>git branch -M main</code>).</li> <li>Empuja tus cambios a GitHub (<code>git push -u origin main</code>).</li> <li>Verifica en GitHub que tus archivos est\u00e1n all\u00ed.</li> </ol> Ejercicio 2 (Opcional, en Pareja): Simulaci\u00f3n B\u00e1sica de Colaboraci\u00f3n <ul> <li>Persona A:<ol> <li>Crea un nuevo repositorio privado en GitHub (ej. <code>CollabApp-Test</code>).</li> <li>Lo clona a su m\u00e1quina.</li> <li>A\u00f1ade un <code>README.md</code> simple y un <code>.gitignore</code>. Hace commit y push.</li> <li>Invita a la Persona B como colaboradora al repositorio en GitHub (Settings &gt; Manage access &gt; Invite a collaborator).</li> </ol> </li> <li>Persona B:<ol> <li>Acepta la invitaci\u00f3n.</li> <li>Clona el repositorio <code>CollabApp-Test</code> a su m\u00e1quina.</li> <li>Modifica el <code>README.md</code> (a\u00f1ade una l\u00ednea o cambia algo).</li> <li>Hace <code>git add README.md</code>, <code>git commit -m \"docs: Actualizaci\u00f3n del README por Persona B\"</code>, y <code>git push</code>.</li> </ol> </li> <li>Persona A:<ol> <li>En su repositorio local, ejecuta <code>git pull origin main</code>.</li> <li>Verifica que el <code>README.md</code> ahora incluye los cambios de la Persona B.</li> </ol> </li> </ul> <p>\u2705 Puntos Clave del M\u00f3dulo 1</p> <ul> <li>Diferencia entre Git (local) y GitHub (remoto/plataforma).</li> <li>Configuraci\u00f3n b\u00e1sica de Git (<code>user.name</code>, <code>user.email</code>).</li> <li>Flujo de trabajo local fundamental: <code>init</code> \u27a1\ufe0f <code>add</code> \u27a1\ufe0f <code>commit</code>.</li> <li>Conexi\u00f3n con GitHub: <code>remote add</code>, <code>push</code>.</li> <li>Obtenci\u00f3n de proyectos: <code>clone</code>.</li> <li>Sincronizaci\u00f3n: <code>pull</code> (para obtener cambios), <code>push</code> (para enviar cambios).</li> <li>Importancia y uso b\u00e1sico de <code>.gitignore</code> y <code>README.md</code>.</li> </ul> <p>Ahora est\u00e1s listo para el siguiente paso: aprender sobre ramas (branches), que son esenciales para el trabajo paralelo y colaborativo.</p>"},{"location":"mergin/","title":"M\u00f3dulo 5: \ud83e\uddec Fusi\u00f3n (Merging) de Cambios y \ud83e\uddf9 Gesti\u00f3n de Ramas","text":"\ud83c\udfaf Objetivo del M\u00f3dulo <p>Aprender a integrar (fusionar) los Pull Requests aprobados en la rama principal (<code>main</code>). Entender las diferentes estrategias de fusi\u00f3n que ofrece GitHub y c\u00f3mo mantener el repositorio limpio eliminando ramas que ya no son necesarias. \u00a1Es hora de que el trabajo de Ana para \"CollabApp\" vea la luz en <code>main</code>!</p>"},{"location":"mergin/#seccion-1-luz-verde-fusionando-un-pull-request-aprobado","title":"\ud83d\ude80 Secci\u00f3n 1: \u00a1Luz Verde! Fusionando un Pull Request Aprobado","text":"<p>Una vez que un Pull Request (PR) ha sido revisado, discutido y aprobado por el equipo (y todas las comprobaciones automatizadas, si las hay, han pasado), est\u00e1 listo para ser fusionado.</p> Requisitos Previos para la Fusi\u00f3n (Generalmente) <ul> <li>\u2705 Al menos una aprobaci\u00f3n (o el n\u00famero requerido por las reglas de protecci\u00f3n de rama).</li> <li>\u2705 No hay solicitudes de cambio pendientes (\"Request changes\").</li> <li>\u2705 No hay conflictos de fusi\u00f3n con la rama base (GitHub lo indicar\u00e1).</li> <li>\u2705 (Idealmente) Las pruebas automatizadas (CI) pasan con \u00e9xito.</li> </ul> <p>\u00bfQui\u00e9n fusiona? Usualmente, puede ser: *   El autor del PR (Ana, en nuestro caso de CollabApp). *   Un l\u00edder de equipo o alguien con permisos de merge en el repositorio.</p> <p>El Bot\u00f3n M\u00e1gico: \"Merge pull request\" En la p\u00e1gina del PR en GitHub, una vez que se cumplen las condiciones, aparecer\u00e1 un bot\u00f3n verde grande: \"Merge pull request\".</p> <ul> <li>Caso CollabApp: El PR de Ana para <code>feature/crear-tarea</code> ha sido aprobado por Bruno y Carla. Ana ve el bot\u00f3n \"Merge pull request\" activo.</li> </ul>"},{"location":"mergin/#seccion-2-estrategias-de-fusion-en-github","title":"\ud83d\udee0\ufe0f Secci\u00f3n 2: Estrategias de Fusi\u00f3n en GitHub","text":"<p>Al hacer clic en la flecha desplegable junto al bot\u00f3n \"Merge pull request\", GitHub ofrece varias estrategias. Las tres principales son:</p> Estrategias de Fusi\u00f3n Detalladas <p>Haz clic para ver las Estrategias de Fusi\u00f3n</p> 1. Create a merge commit (Crear un commit de fusi\u00f3n) - Opci\u00f3n por defecto <p>1. Create a merge commit (Crear un commit de fusi\u00f3n) - Opci\u00f3n por defecto</p> <ul> <li>C\u00f3mo funciona: Todos los commits de la rama de funcionalidad (ej. <code>feature/crear-tarea</code>) se a\u00f1aden al historial de <code>main</code>. Adem\u00e1s, se crea un commit de fusi\u00f3n especial en <code>main</code> que une las dos historias (la de <code>main</code> y la de <code>feature/crear-tarea</code>).</li> <li>Resultado en el historial: Mantiene todo el historial detallado de la rama de funcionalidad. El historial de <code>main</code> se ver\u00e1 como dos l\u00edneas que se unen.</li> <li>Ventajas:<ul> <li>Preserva todo el contexto y el historial granular de la rama.</li> <li>Es f\u00e1cil revertir toda la funcionalidad si es necesario (revirtiendo el commit de fusi\u00f3n).</li> <li>Claro para ver cu\u00e1ndo se integr\u00f3 una rama de funcionalidad.</li> </ul> </li> <li>Desventajas: Puede hacer que el historial de <code>main</code> se vea un poco \"ruidoso\" con muchos commits de fusi\u00f3n si hay muchas ramas peque\u00f1as.</li> <li>\ud83d\udc4d Recomendado para la mayor\u00eda de los equipos, especialmente al empezar.</li> </ul> 2. Squash and merge (Comprimir y fusionar) <p>2. Squash and merge (Comprimir y fusionar)</p> <ul> <li>C\u00f3mo funciona: Combina todos los commits de la rama de funcionalidad en un solo commit en la rama <code>main</code>. GitHub te permite editar el mensaje de este \u00fanico commit, generalmente tomando los mensajes de los commits originales como cuerpo.</li> <li>Resultado en el historial: El historial de <code>main</code> se mantiene lineal y limpio, con un solo commit representando toda la funcionalidad. No se crea un commit de fusi\u00f3n expl\u00edcito.</li> <li>Ventajas:<ul> <li>Historial de <code>main</code> muy limpio y f\u00e1cil de leer.</li> <li>Cada commit en <code>main</code> representa una funcionalidad completa o un arreglo.</li> </ul> </li> <li>Desventajas:<ul> <li>Se pierde el historial detallado de los commits intermedios de la rama de funcionalidad (aunque siguen existiendo en la rama original si no se borra).</li> <li>M\u00e1s dif\u00edcil revertir solo una parte de los cambios de la rama original.</li> </ul> </li> <li>\ud83d\udc4d Bueno para equipos que prefieren un historial de <code>main</code> muy lineal y conciso.</li> </ul> 3. Rebase and merge (Reorganizar y fusionar) <p>3. Rebase and merge (Reorganizar y fusionar)</p> <ul> <li>C\u00f3mo funciona: Toma todos los commits de la rama de funcionalidad y los \"reaplica\" uno por uno encima del \u00faltimo estado de la rama <code>main</code>. No se crea un commit de fusi\u00f3n.</li> <li>Resultado en el historial: El historial de <code>main</code> se mantiene perfectamente lineal, como si todos los commits de la rama de funcionalidad se hubieran hecho directamente en <code>main</code>.</li> <li>Ventajas:<ul> <li>El historial m\u00e1s limpio y lineal posible.</li> </ul> </li> <li>Desventajas:<ul> <li>Puede ser peligroso si la rama ha sido compartida y otros han basado trabajo en ella, ya que reescribe el historial de la rama.</li> <li>Se pierde la informaci\u00f3n contextual de que esos commits proven\u00edan de una rama de funcionalidad espec\u00edfica (a menos que se indique en los mensajes de commit).</li> <li>Puede ser m\u00e1s complejo de manejar si hay conflictos durante el rebase.</li> </ul> </li> <li>\u26a0\ufe0f Usar con precauci\u00f3n y entendimiento. Generalmente para usuarios m\u00e1s avanzados o flujos de trabajo espec\u00edficos.</li> </ul> <ul> <li>Caso CollabApp: Ana decide usar la opci\u00f3n por defecto: \"Create a merge commit\" para su PR <code>feature/crear-tarea</code>.<ol> <li>Hace clic en \"Merge pull request\".</li> <li>GitHub le pide confirmar el mensaje del commit de fusi\u00f3n (generalmente lo autocompleta bien).</li> <li>Hace clic en \"Confirm merge\". \u00a1Listo! Los cambios de <code>feature/crear-tarea</code> ahora est\u00e1n en <code>main</code>.</li> </ol> </li> </ul>"},{"location":"mergin/#seccion-3-limpieza-post-fusion-eliminando-ramas","title":"\ud83e\uddf9 Secci\u00f3n 3: Limpieza Post-Fusi\u00f3n: Eliminando Ramas","text":"<p>Una vez que una rama de funcionalidad ha sido fusionada a <code>main</code> (y ya no se necesita para m\u00e1s desarrollo o correcciones sobre ese mismo PR), es una buena pr\u00e1ctica eliminarla para mantener el repositorio ordenado.</p> \u00bfC\u00f3mo eliminar las ramas? <p>Pasos para Eliminar Ramas Post-Fusi\u00f3n</p> <ol> <li> <ul> <li>Despu\u00e9s de fusionar un PR, GitHub usualmente muestra un bot\u00f3n \"Delete branch\" en la p\u00e1gina del PR. \u00a1Simplemente haz clic en \u00e9l!</li> <li>Si no, puedes ir a la lista de ramas de tu repositorio en GitHub y eliminarla desde all\u00ed.</li> </ul> <p>Eliminar la Rama Remota (en GitHub):</p> <ul> <li>Caso CollabApp: Despu\u00e9s de fusionar, Ana ve el bot\u00f3n \"Delete branch\" para <code>feature/crear-tarea</code> y lo presiona. La rama ya no existe en GitHub.</li> </ul> </li> <li> <p>Eliminar la Rama Local:     La rama todav\u00eda existe en tu repositorio local. Para eliminarla:</p> <p><pre><code># Primero, aseg\u00farate de no estar en la rama que quieres borrar.\n# Cambia a main y actual\u00edzala (muy importante despu\u00e9s de un merge en el remoto):\ngit checkout main\ngit pull origin main  # Esto trae el commit de fusi\u00f3n (y otros cambios) a tu main local\n\n# Ahora, elimina la rama localmente:\ngit branch -d nombre-de-la-rama-fusionada\n# Ejemplo: git branch -d feature/crear-tarea\n</code></pre> *   <code>-d</code> (min\u00fascula) es seguro: solo borrar\u00e1 la rama si ya ha sido fusionada a la rama actual (<code>main</code> en este caso) o a otra rama que tenga <code>main</code> como ancestro. *   <code>-D</code> (MAY\u00daSCULA) fuerza la eliminaci\u00f3n, incluso si la rama no ha sido fusionada. \u00a1\u00dasalo con mucho cuidado!</p> </li> </ol> \u00a1Actualiza <code>main</code> Local Primero! <p>Es crucial hacer <code>git checkout main</code> y luego <code>git pull origin main</code> antes de intentar borrar la rama local con <code>-d</code>. Si no, tu Git local no sabr\u00e1 que la rama ya fue fusionada en el remoto, y <code>git branch -d</code> podr\u00eda dar un error diciendo que la rama no est\u00e1 completamente fusionada.</p>"},{"location":"mergin/#seccion-4-manteniendo-tu-main-local-actualizado","title":"\ud83d\udd04 Secci\u00f3n 4: Manteniendo tu <code>main</code> Local Actualizado","text":"<p>Despu\u00e9s de que un PR es fusionado a <code>main</code> en GitHub (ya sea por ti o por un compa\u00f1ero), tu copia local de <code>main</code> se queda \"atr\u00e1s\". Debes actualizarla para tener los \u00faltimos cambios.</p> <p>Flujo recomendado: ```bash</p>"},{"location":"mergin/#1-cambia-a-tu-rama-main-local","title":"1. Cambia a tu rama main local","text":"<p>git checkout main</p>"},{"location":"mergin/#2-trae-los-cambios-de-la-rama-main-remota-de-github-y-fusionalos","title":"2. Trae los cambios de la rama main remota (de GitHub) y fusi\u00f3nalos","text":"<p>git pull origin main Use code with caution. Markdown Haz esto regularmente, especialmente antes de crear nuevas ramas de funcionalidad, para asegurarte de que partes del c\u00f3digo m\u00e1s reciente. Caso CollabApp: Bruno y Carla, despu\u00e9s de ver que el PR de Ana fue fusionado, ejecutan en sus m\u00e1quinas: git checkout main git pull origin main Use code with caution. Bash Ahora sus ramas main locales tienen la funcionalidad de \"creaci\u00f3n de tareas\". \ud83d\udee0\ufe0f Pr\u00e1ctica Sugerida</p> Ejercicio: Fusi\u00f3n y Limpieza Pasos del Ejercicio Pr\u00e1ctico <p>Escenario: Usar\u00e1s el PR que aprobaste (o te aprobaron) en el M\u00f3dulo 4.</p> <ol> <li> <p>Fusionar el Pull Request:</p> <ul> <li>Ve al PR aprobado en GitHub.</li> <li>Revisa las opciones de fusi\u00f3n (puedes experimentar con \"Squash and merge\" si te sientes aventurero y el PR es tuyo, pero \"Create a merge commit\" es lo m\u00e1s seguro para empezar).</li> <li>Haz clic en \"Merge pull request\" y luego en \"Confirm merge\".</li> <li>\u00a1Observa c\u00f3mo el PR cambia su estado a \"Merged\"!</li> </ul> </li> <li> <p>Eliminar la Rama Remota:</p> <ul> <li>En la p\u00e1gina del PR reci\u00e9n fusionado, busca y haz clic en el bot\u00f3n \"Delete branch\".</li> <li>Verifica en la lista de ramas de tu repositorio en GitHub que la rama de funcionalidad ya no est\u00e1.</li> </ul> </li> <li> <p>Actualizar <code>main</code> Local y Eliminar Rama Local:</p> <ul> <li>En tu terminal, en tu repositorio local:     <code>bash     git checkout main     git pull origin main</code></li> <li>Verifica el historial con <code>git log --oneline --graph</code>. Deber\u00edas ver el commit de fusi\u00f3n (o el commit \"squashed\").</li> <li>Ahora, elimina la rama de funcionalidad localmente:     <code>bash     git branch -d nombre-de-tu-rama-funcionalidad     # Ejemplo: git branch -d feature/mostrar-lista-tareas</code></li> <li>Verifica con <code>git branch</code> que la rama local ha sido eliminada.</li> </ul> </li> <li> <p>(Si trabajas con un compa\u00f1ero): Sincronizaci\u00f3n del Compa\u00f1ero</p> <ul> <li>El compa\u00f1ero que NO fusion\u00f3 el PR debe ahora actualizar su <code>main</code> local:     <code>bash     git checkout main     git pull origin main</code></li> <li>Tambi\u00e9n deber\u00eda eliminar su copia local de la rama de funcionalidad (si la ten\u00eda y ya no la necesita):     <code>bash     git branch -d nombre-de-la-rama-funcionalidad-del-compa\u00f1ero</code> Use code with caution.</li> </ul> </li> </ol> <p>\u2705 Logros de Este M\u00f3dulo</p> <ul> <li>Sabes c\u00f3mo fusionar un Pull Request aprobado en GitHub.</li> <li>Comprendes las diferencias b\u00e1sicas entre las estrategias de fusi\u00f3n: \"Create a merge commit\", \"Squash and merge\", y \"Rebase and merge\".</li> <li>Has aprendido la importancia de eliminar ramas fusionadas (tanto remotas como locales) para mantener el repositorio limpio.</li> <li> <p>Entiendes la necesidad de actualizar tu rama main local (git pull) despu\u00e9s de las fusiones en el remoto. \u00a1Excelente trabajo! Has completado una parte fundamental del ciclo de desarrollo colaborativo. El siguiente desaf\u00edo es aprender a manejar situaciones donde los cambios chocan: los temidos (pero manejables) conflictos de fusi\u00f3n. \u00a1Vamos al M\u00f3dulo 6! Cambios Realizados:</p> </li> <li> <p>Secci\u00f3n 2 (Estrategias de Fusi\u00f3n): He anidado las tres estrategias dentro de un desplegable principal llamado \"Estrategias de Fusi\u00f3n Detalladas\". Cada estrategia individual tambi\u00e9n tiene su propio <code>&lt;summary&gt;</code> para que, si el renderizador lo soporta, puedan ser desplegables anidados. Si no, al menos estar\u00e1n agrupadas bajo el desplegable principal.</p> </li> <li>Secci\u00f3n 3 (Eliminaci\u00f3n de Ramas): Los dos pasos (eliminar rama remota y local) ahora est\u00e1n dentro de un desplegable llamado \"Pasos para Eliminar Ramas Post-Fusi\u00f3n\".</li> <li>Pr\u00e1ctica Sugerida: Los cuatro pasos del ejercicio ahora est\u00e1n dentro de un desplegable llamado \"Pasos del Ejercicio Pr\u00e1ctico\".</li> </ul> <p>Esto deber\u00eda hacer el documento m\u00e1s compacto visualmente, permitiendo al usuario enfocarse en una secci\u00f3n a la vez y expandir los detalles seg\u00fan sea necesario.</p> <p>Verifica si esta estructura y la funcionalidad de los desplegables (si tu visor los soporta) son lo que esperabas. \u00a1Listo para el M\u00f3dulo 6!</p>"},{"location":"ramas/","title":"M\u00f3dulo 2: Ramificaci\u00f3n (Branching) \u2013 Trabajo en Paralelo sin Caos","text":"\ud83c\udfaf Objetivo del M\u00f3dulo <p>Aprender a usar ramas (branches) en Git para aislar el desarrollo de nuevas funcionalidades, correcci\u00f3n de errores o experimentos, sin afectar la l\u00ednea principal de c\u00f3digo (<code>main</code>). Esto es fundamental para el trabajo colaborativo y la organizaci\u00f3n del proyecto \"CollabApp\".</p>"},{"location":"ramas/#1-que-son-las-ramas-branches-por-que-son-cruciales","title":"\ud83c\udf33 1. \u00bfQu\u00e9 son las Ramas (Branches)? \u00bfPor Qu\u00e9 Son Cruciales?","text":"<p>Imagina que la l\u00ednea principal de tu proyecto (<code>main</code>) es el tronco de un \u00e1rbol. Cuando quieres desarrollar una nueva funcionalidad (por ejemplo, un sistema de notificaciones para CollabApp) o corregir un error, no quieres hacerlo directamente sobre el tronco, ya que podr\u00edas desestabilizarlo o introducir c\u00f3digo incompleto.</p> <p>Una rama (branch) es como una nueva rama que crece a partir del tronco (o de otra rama). Te permite:</p> <ul> <li>Aislar el Trabajo: Desarrollar nuevas caracter\u00edsticas o arreglos en un entorno separado.</li> <li>Experimentar sin Riesgo: Si una idea no funciona, puedes descartar la rama sin afectar el c\u00f3digo principal.</li> <li>Trabajo Paralelo: Varios miembros del equipo (Ana, Bruno, Carla) pueden trabajar en diferentes ramas simult\u00e1neamente.</li> <li>Organizaci\u00f3n: Mantener la rama <code>main</code> siempre estable y con c\u00f3digo funcional.</li> </ul> <p>En Esencia: Las ramas son punteros m\u00f3viles a un commit. Crear una rama es simplemente crear un nuevo puntero.</p>"},{"location":"ramas/#2-la-rama-principal-main-antes-master","title":"\ud83c\udf31 2. La Rama Principal: <code>main</code> (Antes <code>master</code>)","text":"<ul> <li>Por convenci\u00f3n, la rama principal de un repositorio se llama <code>main</code>. En proyectos m\u00e1s antiguos, podr\u00edas encontrarla como <code>master</code>.</li> <li>La rama <code>main</code> debe representar, idealmente, la versi\u00f3n estable y lista para producci\u00f3n de tu proyecto.</li> <li>Todo nuevo desarrollo significativo deber\u00eda ocurrir en ramas separadas y luego ser fusionado (merged) a <code>main</code> una vez completado y revisado.</li> </ul>"},{"location":"ramas/#3-creando-una-nueva-rama","title":"\ud83c\udf3f 3. Creando una Nueva Rama","text":"<p>Existen varias formas de crear y cambiar a una nueva rama:</p> Comandos para Crear y Cambiar de Rama <ul> <li> <p>Crear una nueva rama: <pre><code>git branch nombre-de-la-nueva-rama\n</code></pre>     Esto solo crea la rama, pero sigues en tu rama actual.</p> </li> <li> <p>Cambiar a una rama existente (o reci\u00e9n creada): <pre><code>git checkout nombre-de-la-rama\n</code></pre></p> </li> <li> <p>Crear y cambiar a la nueva rama en un solo paso (la forma m\u00e1s com\u00fan): <pre><code>git checkout -b nombre-de-la-nueva-rama\n# Equivalente a:\n# git branch nombre-de-la-nueva-rama\n# git checkout nombre-de-la-nueva-rama\n</code></pre></p> </li> </ul> <ul> <li>Caso CollabApp:<ul> <li>Ana quiere empezar a trabajar en la funcionalidad de \"creaci\u00f3n de tareas\". Decide crear una rama para ello. <pre><code># Asegur\u00e1ndose de estar en la rama main y que est\u00e9 actualizada\ngit checkout main\ngit pull origin main\n\n# Crear y cambiar a la nueva rama\ngit checkout -b feature/crear-tarea\n</code></pre></li> </ul> <p>Convenciones de Nomenclatura de Ramas</p> <p>Es una buena pr\u00e1ctica usar prefijos para indicar el prop\u00f3sito de la rama: *   <code>feature/nombre-funcionalidad</code> (ej. <code>feature/login-usuario</code>) *   <code>fix/descripcion-bug</code> (ej. <code>fix/error-guardado-tareas</code>) *   <code>docs/tema-documentacion</code> (ej. <code>docs/actualizar-readme</code>) *   <code>hotfix/descripcion-urgente</code> (para correcciones cr\u00edticas en producci\u00f3n) Esto ayuda a mantener organizado el listado de ramas.</p> </li> </ul>"},{"location":"ramas/#4-trabajando-en-una-rama","title":"\ud83d\udee0\ufe0f 4. Trabajando en una Rama","text":"<p>Una vez que est\u00e1s en una nueva rama (ej. <code>feature/crear-tarea</code>):</p> <ul> <li>Puedes hacer cambios en los archivos, a\u00f1adir nuevos archivos, etc.</li> <li>Los comandos <code>git add</code> y <code>git commit -m \"mensaje\"</code> funcionan exactamente igual que en la rama <code>main</code>.</li> <li> <p>Importante: Los commits que hagas se registran solo en la rama actual. La rama <code>main</code> (u otras ramas) no se ven afectadas.</p> </li> <li> <p>Caso CollabApp: Ana, en su rama <code>feature/crear-tarea</code>, empieza a crear los archivos HTML y JS para el formulario de creaci\u00f3n de tareas.     <pre><code># (En la rama feature/crear-tarea)\n# Ana crea task-form.html y task-form.js\ntouch task-form.html\ntouch task-form.js\n# Ana a\u00f1ade c\u00f3digo a estos archivos...\n\ngit add task-form.html task-form.js\ngit commit -m \"feat: A\u00f1adir estructura HTML b\u00e1sica para formulario de tareas\"\n# Ana sigue trabajando, hace m\u00e1s commits...\ngit add .\ngit commit -m \"feat: Implementar l\u00f3gica JS inicial para captura de datos del formulario\"\n</code></pre></p> </li> </ul>"},{"location":"ramas/#5-cambiando-entre-ramas","title":"\u21c4 5. Cambiando entre Ramas","text":"<p>Puedes cambiar f\u00e1cilmente entre ramas existentes usando <code>git checkout</code>.</p> <p>```bash git checkout nombre-de-otra-rama Use code with caution. Markdown Caso CollabApp: Mientras Ana trabaja en feature/crear-tarea, surge un bug urgente en main que Bruno debe arreglar. Bruno, en su m\u00e1quina: git checkout main         # Vuelve a la rama main git pull origin main      # Se asegura de tener lo \u00faltimo de main git checkout -b fix/bug-critico-login # Crea una rama para el bug</p>"},{"location":"ramas/#bruno-trabaja-en-la-correccion-y-hace-commits-en-fixbug-critico-login","title":"Bruno trabaja en la correcci\u00f3n y hace commits en fix/bug-critico-login","text":"<p>Use code with caution. Bash Ana puede continuar en feature/crear-tarea sin problemas. Si necesita ver el estado de main, puede hacer: git checkout main</p>"},{"location":"ramas/#observa-el-estado-de-main-pero-no-deberia-hacer-cambios-aqui-directamente","title":"(Observa el estado de main, pero no deber\u00eda hacer cambios aqu\u00ed directamente)","text":"<p>git checkout feature/crear-tarea # Vuelve a su rama de trabajo Use code with caution. Bash</p> <p>Cambios sin Commitear al Cambiar de Rama</p> <p>Si tienes cambios en tu directorio de trabajo que no han sido commiteados (o \"stashed\", que veremos m\u00e1s adelante), Git podr\u00eda impedir que cambies de rama para evitar perder esos cambios o mezclarlos incorrectamente. git status te avisar\u00e1. Siempre es buena idea hacer commit de tus cambios o \"stachearlos\" antes de cambiar de rama si son significativos. \ud83d\udccb 6. Listar Ramas Para ver las ramas de tu repositorio: Listar ramas locales: git branch Use code with caution. Bash La rama actual se marcar\u00e1 con un asterisco (*). Listar ramas remotas (las que est\u00e1n en GitHub y tu Git local conoce): git branch -r Use code with caution. Bash Listar todas las ramas (locales y remotas): git branch -a Use code with caution. Bash \u2601\ufe0f 7. Empujar (Push) Ramas al Repositorio Remoto Por defecto, cuando creas una rama con git branch o git checkout -b, esta rama solo existe en tu repositorio local. Para compartirla con tu equipo (y para poder abrir Pull Requests m\u00e1s adelante), necesitas \"empujarla\" al repositorio remoto (GitHub). git push -u origin nombre-de-tu-rama</p>"},{"location":"ramas/#o-la-forma-mas-corta-si-la-rama-local-tiene-el-mismo-nombre-que-la-remota-deseada","title":"o la forma m\u00e1s corta, si la rama local tiene el mismo nombre que la remota deseada:","text":"<p>git push --set-upstream origin nombre-de-tu-rama Use code with caution. Bash -u o --set-upstream establece una relaci\u00f3n de seguimiento entre tu rama local y la rama remota. Esto significa que en futuros git push o git pull desde esa rama, Git sabr\u00e1 a qu\u00e9 rama remota conectarse por defecto. Despu\u00e9s del primer push con -u, para los siguientes pushes desde esa misma rama, solo necesitar\u00e1s: git push Use code with caution. Bash Caso CollabApp: Ana ha hecho algunos commits en su rama feature/crear-tarea y quiere subirla a GitHub para que otros puedan verla (o para tener un backup).</p>"},{"location":"ramas/#ana-esta-en-la-rama-featurecrear-tarea","title":"(Ana est\u00e1 en la rama feature/crear-tarea)","text":"<p>git push -u origin feature/crear-tarea Use code with caution. Bash Ahora, si Bruno o Carla hacen git fetch o miran en GitHub, ver\u00e1n la rama feature/crear-tarea. \ud83d\udee0\ufe0f Pr\u00e1ctica Sugerida</p> Ejercicio: Trabajando con Ramas en CollabApp <p>Escenario: Eres un desarrollador en el equipo \"Innovatech Solutions\" trabajando en \"CollabApp\". 1. Preparaci\u00f3n: * Aseg\u00farate de tener clonado el repositorio de \"CollabApp\" (o el mi-primer-proyecto-colaborativo del m\u00f3dulo anterior si lo usas para practicar). * Verifica que est\u00e1s en la rama main y que est\u00e1 actualizada con el remoto: bash git checkout main git pull origin main 2.  Crear y Trabajar en una Rama de Funcionalidad:     *   Vas a implementar una nueva funcionalidad: \"Mostrar Lista de Tareas\". Crea una rama para ello:         <code>bash         git checkout -b feature/mostrar-lista-tareas</code>     *   Crea un nuevo archivo llamado <code>task-list.html</code>.     *   A\u00f1ade algo de contenido HTML b\u00e1sico a <code>task-list.html</code> (ej. un t\u00edtulo <code>&lt;h1&gt;Lista de Tareas&lt;/h1&gt;</code> y un <code>&lt;ul&gt;&lt;/ul&gt;</code>).     *   Haz <code>git add task-list.html</code>.     *   Haz un commit: <code>git commit -m \"feat: A\u00f1adir estructura inicial para la lista de tareas\"</code>.     *   Modifica <code>README.md</code> a\u00f1adiendo una l\u00ednea que diga: \"- Funcionalidad en desarrollo: Mostrar lista de tareas.\"     *   Haz <code>git add README.md</code>.     *   Haz un commit: <code>git commit -m \"docs: Actualizar README con info sobre nueva funcionalidad\"</code>.</p> <ol> <li> <p>Simular un Arreglo R\u00e1pido en <code>main</code> (opcional, pero bueno para practicar el cambio):</p> <ul> <li>Imagina que alguien reporta un typo en el <code>README.md</code> de la rama <code>main</code>.</li> <li>Guarda tu trabajo actual en <code>feature/mostrar-lista-tareas</code> (aseg\u00farate de que todo est\u00e9 commiteado).</li> <li>Cambia a la rama <code>main</code>: <code>git checkout main</code>.</li> <li>(Simulaci\u00f3n) Abre <code>README.md</code>, corrige un supuesto typo (o simplemente a\u00f1ade un car\u00e1cter y gu\u00e1rdalo).</li> <li><code>git add README.md</code>.</li> <li><code>git commit -m \"fix: Corregir typo menor en README [main]\"</code>.</li> <li>Vuelve a tu rama de funcionalidad: <code>git checkout feature/mostrar-lista-tareas</code>.     Observa c\u00f3mo <code>task-list.html</code> vuelve a estar presente, y los cambios del <code>README.md</code> de <code>main</code> no est\u00e1n aqu\u00ed (a menos que los fusiones, lo cual veremos despu\u00e9s).</li> </ul> </li> <li> <p>Subir tu Rama de Funcionalidad a GitHub:</p> <ul> <li>Desde tu rama <code>feature/mostrar-lista-tareas</code>, emp\u00fajala al repositorio remoto:     <code>bash     git push -u origin feature/mostrar-lista-tareas</code></li> <li>Ve a GitHub y verifica que tu nueva rama aparece en la lista de ramas del repositorio.</li> </ul> </li> <li> <p>Listar Ramas:</p> <ul> <li>Prueba los comandos:     <code>bash     git branch     git branch -r     git branch -a</code></li> <li>Identifica tu rama local, la rama remota que acabas de crear, y la rama <code>main</code>. Use code with caution.</li> </ul> </li> </ol> <p>\u2705 Puntos Clave del M\u00f3dulo 2</p> <ul> <li>Las ramas permiten el desarrollo aislado y paralelo.</li> <li>La rama main suele ser la rama estable.</li> <li>Comandos esenciales:</li> <li>git branch nombre-rama (crear)</li> <li>git checkout nombre-rama (cambiar)</li> <li>git checkout -b nombre-rama (crear y cambiar)</li> <li>Los commits se hacen en la rama activa.</li> <li>Para compartir una rama, necesitas git push -u origin nombre-rama.</li> <li>git branch, git branch -r, git branch -a para listar ramas. Con el conocimiento de las ramas, estamos listos para el siguiente paso crucial en la colaboraci\u00f3n: los Pull Requests, que es donde proponemos integrar el trabajo de nuestras ramas al c\u00f3digo principal. \u00a1Vamos al M\u00f3dulo 3!</li> </ul>"},{"location":"request/","title":"M\u00f3dulo 3: Pull Requests (PRs) \u2013 El Coraz\u00f3n de la Colaboraci\u00f3n y Revisi\u00f3n","text":"\ud83c\udfaf Objetivo del M\u00f3dulo <p>Entender y utilizar los Pull Requests (PRs) como el mecanismo central en GitHub para proponer, discutir, revisar e integrar cambios de una rama de funcionalidad (o correcci\u00f3n) a la rama principal (ej. <code>main</code>). Este es el pilar de la revisi\u00f3n de c\u00f3digo en el proyecto \"CollabApp\".</p>"},{"location":"request/#1-que-es-un-pull-request-pr-o-merge-request-mr","title":"\ud83d\udde3\ufe0f 1. \u00bfQu\u00e9 es un Pull Request (PR) o Merge Request (MR)?","text":"<p>Un Pull Request (t\u00e9rmino usado en GitHub y Bitbucket) o Merge Request (t\u00e9rmino usado en GitLab) es una solicitud formal para fusionar (merge) los cambios de una rama (la \"rama fuente\" o \"head branch\") en otra rama (la \"rama base\" o \"target branch\", usualmente <code>main</code> o <code>develop</code>).</p> <p>Pero es mucho m\u00e1s que solo una solicitud de fusi\u00f3n:</p> <ul> <li>Plataforma de Discusi\u00f3n: Los PRs proporcionan un espacio para discutir los cambios propuestos. Los miembros del equipo pueden hacer preguntas, ofrecer sugerencias y debatir la implementaci\u00f3n.</li> <li>Revisi\u00f3n de C\u00f3digo (Code Review): Es el lugar donde se realiza la revisi\u00f3n formal del c\u00f3digo. Los revisores pueden examinar los cambios l\u00ednea por l\u00ednea, dejar comentarios y solicitar modificaciones.</li> <li>Integraci\u00f3n Continua (CI): Muchos equipos integran herramientas de CI que ejecutan pruebas automatizadas en el c\u00f3digo del PR antes de que se pueda fusionar.</li> <li>Historial y Trazabilidad: Un PR cerrado (fusionado o no) deja un registro de la discusi\u00f3n y el proceso de decisi\u00f3n sobre un conjunto de cambios.</li> </ul> <p>En CollabApp: Cuando Ana termina la funcionalidad <code>feature/crear-tarea</code>, no la fusiona directamente a <code>main</code>. En su lugar, abre un Pull Request para que Bruno y/o Carla revisen su trabajo.</p>"},{"location":"request/#2-el-flujo-de-un-pull-request-pr","title":"\ud83d\udd04 2. El Flujo de un Pull Request (PR)","text":"<p>El ciclo de vida t\u00edpico de un PR es el siguiente:</p> <ol> <li> <p>Desarrollo en una Rama:</p> <ul> <li>Un desarrollador (ej. Ana) crea una nueva rama (ej. <code>feature/nueva-funcionalidad</code>) a partir de la rama base (<code>main</code>).</li> <li>Ana trabaja en esta rama, haciendo commits con sus cambios.</li> <li>Ana empuja (push) su rama a GitHub: <code>git push -u origin feature/nueva-funcionalidad</code>.</li> </ul> </li> <li> <p>Apertura del Pull Request:</p> <ul> <li>Ana va a la p\u00e1gina del repositorio en GitHub.</li> <li>GitHub a menudo detecta autom\u00e1ticamente las ramas nuevas que se han empujado y ofrece crear un PR.</li> <li>Si no, Ana puede ir a la pesta\u00f1a \"Pull requests\" y hacer clic en \"New pull request\".</li> <li>Selecciona la rama base (ej. <code>main</code>) y la rama a comparar/fuente (ej. <code>feature/nueva-funcionalidad</code>).</li> <li>Escribe un t\u00edtulo claro y una descripci\u00f3n detallada para el PR.</li> <li>Asigna revisores (reviewers) y, si aplica, etiquetas (labels) o hitos (milestones).</li> <li>Hace clic en \"Create pull request\".</li> </ul> </li> <li> <p>Discusi\u00f3n y Revisi\u00f3n de C\u00f3digo:</p> <ul> <li>Los revisores asignados (ej. Bruno, Carla) reciben una notificaci\u00f3n.</li> <li>Examinan los cambios en la pesta\u00f1a \"Files changed\" del PR.</li> <li>Dejan comentarios, hacen preguntas, sugieren mejoras.</li> <li>El autor del PR (Ana) responde a los comentarios y puede hacer m\u00e1s commits en su rama <code>feature/nueva-funcionalidad</code> para abordar el feedback.<ul> <li>Importante: Al empujar nuevos commits a la rama que ya tiene un PR abierto, el PR se actualiza autom\u00e1ticamente con esos nuevos cambios. No es necesario cerrar y abrir un nuevo PR.</li> </ul> </li> </ul> </li> <li> <p>Aprobaci\u00f3n:</p> <ul> <li>Una vez que los revisores est\u00e1n satisfechos con los cambios (y las pruebas automatizadas, si las hay, pasan), aprueban el PR.</li> </ul> </li> <li> <p>Fusi\u00f3n (Merge):</p> <ul> <li>Alguien con permisos (usualmente el autor del PR o un l\u00edder de equipo) fusiona el PR. Esto integra los cambios de <code>feature/nueva-funcionalidad</code> en <code>main</code>.</li> <li>GitHub ofrece diferentes estrategias de fusi\u00f3n (las veremos en el M\u00f3dulo 5).</li> </ul> </li> <li> <p>Cierre y Limpieza (Opcional pero Recomendado):</p> <ul> <li>El PR se cierra autom\u00e1ticamente despu\u00e9s de la fusi\u00f3n.</li> <li>La rama de funcionalidad (<code>feature/nueva-funcionalidad</code>) puede ser eliminada de GitHub (GitHub suele ofrecer un bot\u00f3n para esto) y tambi\u00e9n localmente.</li> </ul> </li> </ol>"},{"location":"request/#3-creando-un-pull-request-en-github","title":"\u270d\ufe0f 3. Creando un Pull Request en GitHub","text":"<ul> <li> <p>Caso CollabApp: Ana ha terminado su trabajo inicial en la rama <code>feature/crear-tarea</code> y la ha empujado a GitHub. Ahora quiere proponer estos cambios para <code>main</code>.</p> <ol> <li>Ir a GitHub: Ana navega al repositorio <code>CollabApp</code> en GitHub.</li> <li>Iniciar el PR:<ul> <li>A menudo, GitHub mostrar\u00e1 una notificaci\u00f3n amarilla: \"<code>feature/crear-tarea</code> had recent pushes less than a minute ago\" con un bot\u00f3n \"Compare &amp; pull request\". Ana hace clic ah\u00ed.</li> <li>Alternativamente, puede ir a la pesta\u00f1a \"Pull requests\" y hacer clic en \"New pull request\".</li> </ul> </li> <li>Seleccionar Ramas:<ul> <li><code>base:</code> <code>main</code> (la rama a la que quiere fusionar)</li> <li><code>compare:</code> <code>feature/crear-tarea</code> (la rama que contiene sus cambios) GitHub mostrar\u00e1 una vista previa de los cambios y si hay conflictos (\u00a1esperemos que no!).</li> </ul> </li> <li>Completar los Detalles del PR:<ul> <li>T\u00edtulo: Un t\u00edtulo conciso y descriptivo.<ul> <li>Ejemplo para Ana: <code>feat: Implementar funcionalidad b\u00e1sica de creaci\u00f3n de tareas</code></li> </ul> </li> <li>Descripci\u00f3n (Cuerpo): Esta es la parte crucial. Deber\u00eda explicar:<ul> <li>\u00bfQu\u00e9 hace este PR? (Resumen de los cambios).</li> <li>\u00bfPor qu\u00e9 es necesario este cambio? (Contexto, problema que resuelve, issue que cierra).</li> <li>\u00bfC\u00f3mo se probaron los cambios? (Pasos para que los revisores puedan verificar).</li> <li>(Opcional) Capturas de pantalla, GIFs de la nueva UI.</li> <li>(Opcional) Si cierra un \"Issue\" de GitHub, puede escribir <code>Closes #ID_DEL_ISSUE</code> (ej. <code>Closes #12</code>). Esto vincular\u00e1 el PR al issue y lo cerrar\u00e1 autom\u00e1ticamente cuando el PR se fusione.</li> <li>Ejemplo de descripci\u00f3n para Ana: <pre><code>Este PR introduce la funcionalidad b\u00e1sica para que los usuarios puedan crear nuevas tareas en CollabApp.\n\n**Cambios Realizados:**\n- A\u00f1adido `task-form.html` con la estructura del formulario.\n- Creado `task-form.js` para manejar la entrada del usuario (sin l\u00f3gica de guardado a\u00fan).\n- Actualizado `README.md` para mencionar esta nueva caracter\u00edstica.\n\n**Motivaci\u00f3n:**\nEste es el primer paso para permitir a los usuarios a\u00f1adir contenido a la aplicaci\u00f3n.\nRelacionado con el Issue #3 (Definir flujo de creaci\u00f3n de tareas).\n\n**C\u00f3mo Probar:**\n1.  Navegar a `task-form.html` en el navegador.\n2.  Verificar que el formulario se muestra correctamente.\n3.  (No hay funcionalidad de guardado a\u00fan).\n\n@Bruno @Carla \u00a1Por favor, revisen!\n</code></pre></li> </ul> </li> <li>Reviewers (Revisores): En el panel derecho, Ana selecciona a Bruno y Carla como revisores.</li> <li>Assignees (Asignados): Ana puede asignarse a s\u00ed misma como responsable del PR.</li> <li>Labels (Etiquetas): Puede a\u00f1adir etiquetas como <code>enhancement</code>, <code>frontend</code>, <code>needs-review</code>.</li> <li>Projects/Milestones: Si se usan, se pueden vincular aqu\u00ed.</li> </ul> </li> <li>Crear el PR: Ana hace clic en \"Create pull request\".</li> </ol> <p>El PR ahora est\u00e1 abierto, y Bruno y Carla recibir\u00e1n notificaciones para revisarlo.</p> </li> </ul>"},{"location":"request/#4-el-ciclo-de-vida-de-un-pr-discusion-y-actualizaciones","title":"\ud83d\udd04 4. El Ciclo de Vida de un PR: Discusi\u00f3n y Actualizaciones","text":"<p>Una vez que el PR est\u00e1 abierto:</p> <ol> <li>Notificaci\u00f3n a Revisores: Bruno y Carla son notificados.</li> <li>Revisi\u00f3n: (Esto se detalla en el M\u00f3dulo 4). Los revisores miran los archivos cambiados, dejan comentarios, etc.</li> <li>Feedback y Cambios Adicionales:<ul> <li>Supongamos que Bruno encuentra un peque\u00f1o error o sugiere una mejora en el <code>task-form.js</code> de Ana.</li> <li>Ana ve el comentario de Bruno.</li> <li>Ana hace los cambios necesarios en su rama local <code>feature/crear-tarea</code>.</li> <li>Hace un nuevo commit: <code>git commit -m \"fix: Corregir error en validaci\u00f3n de formulario seg\u00fan feedback\"</code>.</li> <li>Empuja (push) esos nuevos commits a la misma rama en GitHub: <code>git push origin feature/crear-tarea</code>.</li> <li>\u00a1Magia! El Pull Request en GitHub se actualiza autom\u00e1ticamente para incluir estos nuevos commits. Bruno y Carla ver\u00e1n los cambios m\u00e1s recientes.</li> </ul> </li> <li>Repetir: Este ciclo de revisi\u00f3n-feedback-cambio puede repetirse hasta que todos est\u00e9n satisfechos.</li> <li>Aprobaci\u00f3n: Los revisores marcan el PR como \"Approved\".</li> <li>Fusi\u00f3n: (Se detalla en el M\u00f3dulo 5).</li> </ol>"},{"location":"request/#practica-sugerida","title":"\ud83d\udee0\ufe0f Pr\u00e1ctica Sugerida","text":"Ejercicio: Abriendo tu Primer Pull Request <p>Escenario: Contin\u00faas con el trabajo de la rama <code>feature/mostrar-lista-tareas</code> (o la que creaste en el M\u00f3dulo 2) en el proyecto \"CollabApp\" (o tu proyecto de pr\u00e1ctica). 1.  Asegurar Cambios en GitHub:     *   Si no lo hiciste al final del M\u00f3dulo 2, aseg\u00farate de que tu rama de funcionalidad (ej. <code>feature/mostrar-lista-tareas</code>) con sus commits est\u00e9 empujada (push) a GitHub.         <pre><code># (Estando en tu rama de funcionalidad)\ngit push origin feature/mostrar-lista-tareas \n</code></pre> (Si ya hiciste el <code>git push -u ...</code> antes, solo <code>git push</code> es suficiente).</p> <ol> <li> <p>Crear el Pull Request en GitHub:</p> <ul> <li>Ve a la p\u00e1gina de tu repositorio en GitHub.</li> <li>Busca la notificaci\u00f3n para crear un PR para tu rama o ve a la pesta\u00f1a \"Pull requests\" y haz clic en \"New pull request\".</li> <li>Base: Selecciona <code>main</code>.</li> <li>Compare: Selecciona tu rama de funcionalidad (ej. <code>feature/mostrar-lista-tareas</code>).</li> <li>T\u00edtulo: Escribe un t\u00edtulo claro, ej: <code>feat: Implementar visualizaci\u00f3n inicial de la lista de tareas</code>.</li> <li>Descripci\u00f3n:<ul> <li>Describe brevemente qu\u00e9 hace el PR.</li> <li>Menciona los archivos principales que modificaste.</li> <li>Si est\u00e1s practicando solo, puedes escribir: \"Este PR a\u00f1ade la estructura b\u00e1sica para mostrar la lista de tareas. Listo para revisi\u00f3n (por m\u00ed mismo en este caso de pr\u00e1ctica \ud83d\ude09).\"</li> <li>Si est\u00e1s practicando con un compa\u00f1ero, menci\u00f3nalo con <code>@nombredeusuario</code> y p\u00eddele que revise.</li> </ul> </li> <li>Reviewers: Si tienes un compa\u00f1ero, as\u00edgnaselo. Si est\u00e1s solo, puedes omitir esto o asignarte a ti mismo (aunque es un poco redundante).</li> <li>Labels: (Opcional) A\u00f1ade una etiqueta como <code>feature</code> o <code>frontend</code>.</li> <li>Haz clic en \"Create pull request\".</li> </ul> </li> <li> <p>Explorar el PR Creado:</p> <ul> <li>Una vez creado, explora las diferentes pesta\u00f1as del PR:<ul> <li>Conversation: Donde ver\u00e1s la descripci\u00f3n y donde aparecer\u00e1n los comentarios.</li> <li>Commits: Lista de los commits incluidos en este PR.</li> <li>Checks: (Si hay CI configurada) Estado de las pruebas.</li> <li>Files changed: \u00a1La m\u00e1s importante para la revisi\u00f3n! Aqu\u00ed ves las diferencias (diffs) de cada archivo modificado.</li> </ul> </li> </ul> </li> <li> <p>(Opcional - Si tienes un compa\u00f1ero o quieres simularlo): Iterar</p> <ul> <li>Imagina que un revisor te pide un peque\u00f1o cambio (ej. cambiar el texto de un t\u00edtulo en <code>task-list.html</code>).</li> <li>En tu m\u00e1quina local, en tu rama de funcionalidad (<code>feature/mostrar-lista-tareas</code>):<ul> <li>Haz el cambio solicitado en <code>task-list.html</code>.</li> <li><code>git add task-list.html</code></li> <li><code>git commit -m \"style: Actualizar t\u00edtulo seg\u00fan feedback de revisi\u00f3n\"</code></li> <li><code>git push origin feature/mostrar-lista-tareas</code></li> </ul> </li> <li>Vuelve al PR en GitHub y observa c\u00f3mo se actualiza autom\u00e1ticamente con el nuevo commit y los cambios en la pesta\u00f1a \"Files changed\".</li> </ul> </li> </ol> <p>\u2705 Puntos Clave del M\u00f3dulo 3</p> <ul> <li>Un Pull Request (PR) es el mecanismo para proponer y discutir la integraci\u00f3n de cambios de una rama a otra (generalmente <code>main</code>).</li> <li>Flujo b\u00e1sico: <code>crear rama</code> \u27a1\ufe0f <code>hacer commits</code> \u27a1\ufe0f <code>push de la rama</code> \u27a1\ufe0f <code>abrir PR en GitHub</code>.</li> <li>Un buen PR tiene un t\u00edtulo claro y una descripci\u00f3n detallada.</li> <li>Los PRs son el lugar para la revisi\u00f3n de c\u00f3digo y la discusi\u00f3n.</li> <li>Los nuevos commits empujados a una rama con un PR abierto actualizan autom\u00e1ticamente el PR.</li> </ul> <p>\u00a1Excelente! Ahora que sabes c\u00f3mo proponer cambios formalmente, el siguiente paso es aprender c\u00f3mo realizar y recibir revisiones de c\u00f3digo efectivas dentro de estos Pull Requests. \u00a1Nos vemos en el M\u00f3dulo 4!</p>"},{"location":"revision/","title":"M\u00f3dulo 4: \ud83d\udd2c Revisi\u00f3n de C\u00f3digo y \ud83d\udcac Discusi\u00f3n Constructiva en Pull Requests","text":"\ud83c\udfaf Objetivo del M\u00f3dulo <p>Dominar el arte de la revisi\u00f3n de c\u00f3digo (Code Review) dentro de GitHub. Aprender\u00e1s a dar y recibir feedback de manera efectiva, asegurando la calidad y fomentando el conocimiento compartido en el equipo de \"CollabApp\".</p>"},{"location":"revision/#seccion-1-el-valor-incalculable-de-la-revision-de-codigo","title":"\ud83c\udf1f Secci\u00f3n 1: El Valor Incalculable de la Revisi\u00f3n de C\u00f3digo","text":"<p>La revisi\u00f3n de c\u00f3digo no es solo \"mirar c\u00f3digo ajeno\"; es una piedra angular para construir software robusto y equipos fuertes.</p> \u00bfPor qu\u00e9 es tan importante? <ul> <li>\ud83d\udee1\ufe0f Caza de Errores Temprana: Detectar bugs, fallos l\u00f3gicos y posibles problemas de seguridad antes de que se integren.</li> <li>\ud83d\udcda Transferencia de Conocimiento: El equipo aprende colectivamente. Si Ana implementa algo nuevo, Bruno y Carla lo entienden al revisarlo.</li> <li>\ud83c\udf93 Mentor\u00eda y Crecimiento: Los desarrolladores senior gu\u00edan a los junior, y todos aprenden nuevas t\u00e9cnicas.</li> <li>\u2728 Consistencia y Calidad: Se asegura que el c\u00f3digo sigue los est\u00e1ndares del equipo, es legible y mantenible.</li> <li>\ud83c\udfd7\ufe0f Validaci\u00f3n de Dise\u00f1o: A veces, una segunda mirada revela mejores enfoques arquitect\u00f3nicos.</li> </ul> <p>Para CollabApp: Cada l\u00ednea de c\u00f3digo destinada a <code>main</code> pasa por este escrutinio colaborativo.</p>"},{"location":"revision/#seccion-2-el-proceso-de-revision-en-github-paso-a-paso","title":"\ud83d\udd75\ufe0f Secci\u00f3n 2: El Proceso de Revisi\u00f3n en GitHub: Paso a Paso","text":"<p>Cuando te toca ser el detective (revisor) de un Pull Request:</p> <ol> <li> <p>\ud83c\udf0d Comprende la Misi\u00f3n (Contexto del PR):</p> <ul> <li>Lee con atenci\u00f3n el T\u00edtulo y la Descripci\u00f3n del PR. \u00bfCu\u00e1l es su prop\u00f3sito?</li> <li>Si hay un Issue vinculado, \u00a1rev\u00edsalo tambi\u00e9n!</li> </ul> </li> <li> <p>\ud83d\udd0d Examina las Pistas (Pesta\u00f1a \"Files changed\"):</p> <ul> <li>Esta es tu sala de interrogatorios. Ver\u00e1s:<ul> <li>Archivos a\u00f1adidos, modificados o eliminados.</li> <li>L\u00edneas en rojo (lo que se quit\u00f3/cambi\u00f3).</li> <li>L\u00edneas en verde (lo que se a\u00f1adi\u00f3/cambi\u00f3).</li> </ul> </li> </ul> </li> <li> <p>\u270d\ufe0f Deja tus Notas (Comentarios):</p> <ul> <li>Comentarios Generales: En la pesta\u00f1a \"Conversation\" para ideas globales sobre el PR.<ul> <li>Ejemplo: \"\u00a1Excelente trabajo con la estructura general! Solo tengo una duda sobre el rendimiento de esta consulta...\"</li> </ul> </li> <li>Comentarios Espec\u00edficos en L\u00ednea:<ul> <li>En \"Files changed\", haz clic en el <code>+</code> azul que aparece al lado de una l\u00ednea de c\u00f3digo.</li> <li>Puedes comentar una sola l\u00ednea o seleccionar un rango.</li> <li>Ejemplo: En una l\u00ednea con <code>let x = data[0];</code>, podr\u00edas comentar: \"\u00bfSer\u00eda <code>firstElement</code> un nombre m\u00e1s descriptivo para <code>x</code> aqu\u00ed?\"</li> </ul> </li> <li>\ud83d\udca1 Sugerencias de Cambio (GitHub Suggestions): \u00a1Tu varita m\u00e1gica para cambios peque\u00f1os!<ul> <li>Dentro de un comentario en l\u00ednea, usa:     <pre><code>```suggestion\n// C\u00f3digo que sugieres\nconst firstElement = data[0];\n</code></pre>     ```</li> <li>El autor puede aplicar tu sugerencia con un clic.</li> </ul> </li> </ul> </li> <li> <p>\u2696\ufe0f Emite tu Veredicto (Iniciar una Revisi\u00f3n Formal):</p> <ul> <li>Bot\u00f3n \"Review changes\" (arriba en \"Files changed\"):<ul> <li>\ud83d\udcac Comment: Dejas tus comentarios, pero no bloqueas la fusi\u00f3n. \u00datil para preguntas menores o si no tienes tiempo para una revisi\u00f3n completa a\u00fan.</li> <li>\ud83d\udc4d Approve: \u00a1Luz verde! Los cambios te parecen correctos y listos para fusionar.</li> <li>\u26a0\ufe0f Request changes: \u00a1Luz roja! Has encontrado problemas que deben ser resueltos antes de la fusi\u00f3n. Explica claramente qu\u00e9 se necesita.</li> </ul> </li> </ul> </li> </ol> En la Pr\u00e1ctica con CollabApp <p>Bruno revisa el PR de Ana (<code>feature/crear-tarea</code>): 1.  Lee que Ana implement\u00f3 el formulario de creaci\u00f3n. 2.  En <code>task-form.js</code> (en \"Files changed\"), ve <code>let c = 0;</code>. 3.  Bruno comenta en esa l\u00ednea: \"\u00bfPodr\u00edamos usar <code>counter</code> en lugar de <code>c</code> para mayor claridad?\" y adem\u00e1s, usa una <code>suggestion</code> para proponer <code>let counter = 0;</code>. 4.  Encuentra una l\u00f3gica que podr\u00eda ser un poco confusa. 5.  Decide hacer clic en \"Review changes\" y selecciona \"Request changes\", resumiendo: \"Buen inicio Ana. Por favor, revisa el nombre de la variable <code>c</code> y considera simplificar la l\u00f3gica en la funci\u00f3n X. \u00a1Gracias!\".</p>"},{"location":"revision/#seccion-3-guia-del-buen-revisor","title":"\ud83c\udfaf Secci\u00f3n 3: Gu\u00eda del Buen Revisor","text":"\ud83d\udc4d Qu\u00e9 HACER (Do's) \ud83d\udc4e Qu\u00e9 NO HACER (Don'ts) \u2705 Ser constructivo y amable. \u274c Ser cr\u00edtico o condescendiente. \u2705 Ser claro y espec\u00edfico en tus comentarios. \u274c Dejar comentarios vagos como \"esto est\u00e1 mal\". \u2705 Explicar el por qu\u00e9 de tus sugerencias. \u274c Asumir que el autor entender\u00e1 tu intenci\u00f3n sin contexto. \u2705 Enfocarse en correctitud, dise\u00f1o, legibilidad. \u274c \"Nitpickear\" en exceso sobre estilo si hay linters. \u2705 Ofrecer alternativas o ejemplos si es posible. \u274c Solo se\u00f1alar problemas sin dar pistas de soluci\u00f3n. \u2705 Revisar de manera oportuna. \u274c Dejar PRs en el limbo por d\u00edas sin comunicaci\u00f3n. \u2705 Hacer preguntas si algo no est\u00e1 claro. \u274c Aprobar ciegamente sin entender los cambios. \u2705 Reconocer el buen trabajo tambi\u00e9n. \u274c Solo enfocarse en lo negativo."},{"location":"revision/#seccion-4-guia-del-autor-del-pr-recibiendo-feedback","title":"\ud83d\udee1\ufe0f Secci\u00f3n 4: Gu\u00eda del Autor del PR (Recibiendo Feedback)","text":"<p>Recibir cr\u00edticas, incluso constructivas, requiere una mentalidad abierta.</p> \ud83d\udc4d Qu\u00e9 HACER (Do's) \ud83d\udc4e Qu\u00e9 NO HACER (Don'ts) \u2705 No tomarlo personal. Es sobre el c\u00f3digo. \u274c Ponerse a la defensiva o discutir cada punto. \u2705 Agradecer el tiempo del revisor. \u274c Ignorar los comentarios o responder de mala gana. \u2705 Entender bien el comentario antes de actuar. \u274c Hacer cambios sin entender completamente el feedback. \u2705 Discutir constructivamente si hay desacuerdos. \u274c Quedarse callado si no se est\u00e1 de acuerdo o no se entiende. \u2705 Hacer los cambios solicitados (o justificar). \u274c Dejar el PR abandonado tras recibir feedback. \u2705 Commitear y pushear los cambios a la misma rama. \u274c Abrir un nuevo PR para los mismos cambios. \u2705 Notificar al revisor cuando los cambios est\u00e9n listos. \u274c Asumir que el revisor adivinar\u00e1 que actualizaste el PR. Ana Responde al Feedback de Bruno <ol> <li>Ana lee los comentarios de Bruno en su PR.</li> <li>Agradece a Bruno: \"@Bruno \u00a1Gracias por la revisi\u00f3n detallada!\"</li> <li>Cambia <code>let c = 0;</code> a <code>let counter = 0;</code> en su c\u00f3digo local.</li> <li>Reflexiona sobre la l\u00f3gica que Bruno mencion\u00f3 y encuentra una forma de simplificarla.</li> <li>Hace un nuevo commit: <code>git commit -m \"refactor: Mejorar nombres de variables y simplificar l\u00f3gica seg\u00fan revisi\u00f3n\"</code></li> <li><code>git push origin feature/crear-tarea</code> (el PR se actualiza).</li> <li>Responde a los comentarios de Bruno en GitHub, explicando los cambios y marcando las conversaciones como resueltas si procede.</li> <li>Comenta en el PR: \"@Bruno \u00a1Listo! He aplicado tus sugerencias. \u00bfPodr\u00edas echarle otro vistazo?\"</li> </ol>"},{"location":"revision/#seccion-5-el-ciclo-de-iteracion-y-la-aprobacion-final","title":"\ud83d\udd04 Secci\u00f3n 5: El Ciclo de Iteraci\u00f3n y la Aprobaci\u00f3n Final","text":"<ol> <li>Iteraci\u00f3n: El ping-pong de [Revisi\u00f3n \u27a1\ufe0f Feedback \u27a1\ufe0f Cambios del Autor \u27a1\ufe0f Nuevo Push \u27a1\ufe0f Siguiente Revisi\u00f3n] es normal.</li> <li>Resolver Conversaciones: En GitHub, una vez que un punto de discusi\u00f3n est\u00e1 solucionado, se puede marcar como \"Resolved\". Esto ayuda a limpiar la vista del PR.</li> <li>\u00a1Luz Verde! (Aprobaci\u00f3n):<ul> <li>Cuando los revisores est\u00e1n satisfechos, seleccionan \"Approve\" en su revisi\u00f3n.</li> <li>Dependiendo de las reglas del repositorio (branch protection rules), puede que se necesite un n\u00famero m\u00ednimo de aprobaciones.</li> </ul> </li> </ol> La Aprobaci\u00f3n en CollabApp <p>Bruno revisa los \u00faltimos cambios de Ana. Todo est\u00e1 perfecto. *   Bruno va a \"Review changes\" en el PR. *   Escribe un comentario final: \"\u00a1Se ve genial ahora, Ana! Buen trabajo.\" *   Selecciona \"Approve\". Carla tambi\u00e9n revisa y aprueba. El PR de Ana ahora tiene el visto bueno del equipo.</p>"},{"location":"revision/#practica-sugerida-el-duelo-de-revisiones","title":"\ud83d\udee0\ufe0f Pr\u00e1ctica Sugerida: El Duelo de Revisiones \ud83e\udd3a","text":"Ejercicio: Revisi\u00f3n Cruzada (Ideal en Parejas) <p>Objetivo: Simular el ciclo completo de revisi\u00f3n. Si est\u00e1s solo, juega ambos roles.</p> <p>Fase 1: Preparaci\u00f3n (Autor) 1.  Aseg\u00farate de tener un PR abierto del M\u00f3dulo 3 (ej., <code>feature/mostrar-lista-tareas</code>). 2.  (Para el ejercicio) Introduce sutilmente 1 o 2 \"\u00e1reas de mejora\" en tu c\u00f3digo (un nombre de variable confuso, una peque\u00f1a l\u00f3gica repetida, un comentario obsoleto). 3.  Haz commit y push de estos cambios a tu rama de funcionalidad. Tu PR se actualizar\u00e1.</p> <p>Fase 2: La Revisi\u00f3n (Revisor) 1.  (Si tienes compa\u00f1ero, intercambien PRs). Abre el PR a revisar. 2.  Misi\u00f3n: Encuentra las \"\u00e1reas de mejora\" y sugiere correcciones. 3.  Deja al menos:     *   Un comentario en l\u00ednea espec\u00edfico.     *   Una \"GitHub Suggestion\" para un cambio directo.     *   Un comentario general en la pesta\u00f1a \"Conversation\" del PR. 4.  Env\u00eda tu revisi\u00f3n formal: <code>Request changes</code> (si encontraste cosas a mejorar) o <code>Comment</code>.</p> <p>Fase 3: La Respuesta (Autor) 1.  Recibe el feedback. Agradece. 2.  En tu rama local, aplica las correcciones/sugerencias. 3.  Haz commit y push de los arreglos. 4.  Responde a los comentarios en GitHub, explicando tus acciones. Marca conversaciones como resueltas. 5.  Notifica al revisor que el PR est\u00e1 listo para una segunda mirada.</p> <p>Fase 4: La Aprobaci\u00f3n (Revisor) 1.  Revisa los cambios actualizados. 2.  Si todo est\u00e1 en orden, cambia tu revisi\u00f3n a <code>Approve</code>. \u00a1Victoria!</p> <p>\u2705 Logros de Este M\u00f3dulo</p> <ul> <li>Comprendes el valor fundamental de la revisi\u00f3n de c\u00f3digo.</li> <li>Sabes c\u00f3mo navegar y usar las herramientas de revisi\u00f3n de PRs en GitHub (comentarios, sugerencias, aprobaci\u00f3n/solicitud de cambios).</li> <li>Conoces las buenas pr\u00e1cticas tanto para ser un revisor efectivo como para recibir feedback constructivamente.</li> <li>Has practicado el ciclo iterativo de revisi\u00f3n y mejora.</li> </ul> <p>Con tus cambios revisados y aprobados, \u00a1est\u00e1s a un paso de integrarlos! El pr\u00f3ximo m\u00f3dulo trata sobre c\u00f3mo fusionar esos Pull Requests y gestionar tus ramas post-fusi\u00f3n. \u00a1Adelante al M\u00f3dulo 5!</p>"}]}